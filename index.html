<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Apple macOS version 5.6.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Mathematical Foundations Group PhD Offers</title>
  <link href="G/Site.css" type="text/css" rel="stylesheet">
  <script>
  window.MathJax = {
  tex: {
    macros: {
      f: "{\\mathsf f}",
      t: "{\\mathsf t}",
      SKS: "{\\mathsf{SKS}}",
      id: "{\\mathsf i{\\downarrow}}",
      wd: "{\\mathsf w{\\downarrow}}",
      cd: "{\\mathsf c{\\downarrow}}",
      iu: "{\\mathsf i{\\uparrow}}",
      wu: "{\\mathsf w{\\uparrow}}",
      cu: "{\\mathsf c{\\uparrow}}",
      s: "{\\mathsf s}",
      m: "{\\mathsf m}",
      inf: ["{\\scriptsize #1}\\dfrac{\\strut #2}{\\strut #3}",3]
    },
    autoload: {
      color: [],
      colorV2: ['color']
    },
    packages: {'[+]': ['noerrors']}
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/noerrors']
  }
  };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" id="MathJax-script"></script>
</head>
<body>
<h4>
University of Bath – Computer Science Department
</h4>
<h1>
Mathematical Foundations Group PhD Projects
</h1>

<p>
Our group explores some of the deepest topics in logic and its relation to the theory of computation. We establish bridges between proof theory, category theory, semantics and complexity, so that the methods of each discipline enrich the others. We design new theories and solve old problems. For example, we defined a new formalism, called <i>open deduction</i>, that allowed us to obtain the most efficient known notion of computation for the lambda-calculus. That was made possible by introducing ideas from complexity theory and category theory into proof theory and its computational interpretations.
</p>

<p>
Our research programme, in a nutshell, is to help develop the mathematics of computation. This matters at least for two reasons. The first is that computing, at present, is art, not engineering. Indeed, because of the lack of mathematics, software correctness is not guaranteed the same way a bridge is guaranteed to stand, for example. The second reason is that the theory of computation is rapidly becoming one of the most important intellectual achievements of civilisation. For example, it is now helping physics and biology create new models in their domain. Because of all that, our doctoral graduates have embarked on excellent academic careers in some of the most intellectually rewarding and innovative branches of research, and will continue to do so.
</p>

<h2>
Projects
</h2>

<h3>
Verification for Real Polynomial Arithmetic
</h3>

<p>
<a href="https://people.bath.ac.uk/masrjb/">Russell Bradford</a>
and
<a href="https://people.bath.ac.uk/masjhd/">James Davenport</a>
</p>

<p>
Many problems in building verified software systems in the real world (e.g. air traffic control) involve the proof of statements about real polynomial arithmetic, often including inequalities. In principle we have known how to solve such systems for many years, but the theoretical, and too often the practical, complexity is excessive.  There has been much work, at Bath, Coventry and elsewhere, in reducing the cost for important special cases, notably the cases when there are equations as well as inequalities. However, this leads to a large piece of software, resting on fairly complicated theorems.
</p>

<p>
Recent research by Bath, Coventry and RWTH has produced a <a href="https://arxiv.org/abs/2004.04034">method</a> which converts such a problem into a sequence of simpler statements, which may be much easier to verify with a more conventional theorem prover. This has yet to be checked in practice, which is the goal of this project. As a PhD student, you would be working alongside the joint Bath-Coventry EPSRC-funded project, which would provide several colleagues and a large software base to start from.
</p>

<h3>
New Foundations of Proof Theory From a Novel Notion of Substitution
</h3>

<p>
<a href="http://alessio.guglielmi.name/">Alessio Guglielmi</a>
</p>

<p>
What is a proof? What is an algorithm? We understand much of WHAT can be proved and computed but we do not have yet a good theory of HOW this is done. For example, we cannot say when two given proofs or algorithms are the same, in the sense that they prove or compute something using the same method. It is a somewhat embarrassing problem to have, given that, in most branches of mathematics, we can compare objects. For instance, we can reduce two polynomials to some canonical form, like maximal factorisation, and use that for a comparison.
</p>

<p>
The source of the problem is the languages in which proofs and algorithms are represented because they model their underlying mathematical structure. In traditional proof theory, the mathematical properties of those structures are too poor. To address the problem, for the past two decades we have been building a new proof theory, called 'deep inference', whose emphasis is in HOW proofs, and by extension algorithms, are composed. That requires new languages and new design principles. One current focus of research is developing a notion of substitution for proofs, which, among other properties, should enable a powerful form of factorisation. We propose PhD projects contributing to this effort. These are foundational problems for proof theory, meaning that talent for algebra and combinatorics is more important than knowledge of logic.
</p>

<h3>
A New Approach to Computational Effects in Lambda-Calculus
</h3>

<p>
<a href="http://www.cs.bath.ac.uk/~wbh22/">Willem Heijltjes</a>
</p>

<p>
A key property of the lambda-calculus, as a model of computation, is confluence: it means that we can reason about the <i>outcome</i> of a computation separately from the <i>process</i>; in other words, we can separate the <i>denotational</i> from the <i>operational</i>. When computational effects are introduced, as would be essential for a real-world functional programming language, confluence is however lost, and the outcome of a computation becomes dependent on the chosen reduction strategy.
</p>

<p>
In this project we are working towards a new way of incorporating effects into the lambda-calculus. Rather than adding new primitives, we decompose the existing constructs of the lambda-calculus, which can then be used to encode various imperative features such as sequencing, state update and retrieval, and input and output. The approach preserves confluence and gives a new way of typing computational effects, which opens up new denotational and operational perspectives. As a PhD student, you would contribute to the development and extension of this promising new paradigm. Your work would draw on ideas from type theory, proof theory including deep inference and categorical logic, and denotational semantics as well as lambda calculus.
</p>

<h3>
Quantitative Game Semantics
</h3>

<p>
<a href="http://www.cs.bath.ac.uk/~jl317/">Jim Laird</a>
</p>

<p>
Denotational semantics builds abstractions of computer programs and concurrent systems, which allows us to look past their syntax and represent them using mathematical structures from a range of fields such as algebra and topology. These come with powerful theorems and techniques which we can use to prove that programs and protocols are correct, secure and efficient.
</p>

<p>
Moving beyond binary properties: “Does this program terminate?” “Might it deadlock?” to quantitative ones: “What is its evaluation cost in time or space?” “What is the probability of returning a value?” requires models which can capture program behaviour - on which these properties depend - in a way which is abstract, structured and precise.
</p>

<p>
Game semantics provides such a representation by modelling computation as a two-player game between a program or agent and its environment. It is intuitively appealing and has profound connections with fields from category theory to automata theory.
</p>

<p>
This project will use these connections to investigate the relationship between games and quantitative properties of programs, and use these foundations to build new models and discover new theories.
</p>

<h3>
Intersection-Type Semantics of Imperative Programming
</h3>

<p>
<a href="http://www.cs.bath.ac.uk/~gam23/">Guy McCusker</a>
</p>

<p>
Imperative programming offers fast programs and fine control over execution, but is hard to verify, mainly due to the difficulty of giving a good semantics. In this project you would investigate a new approach based on intersection types, expressed in open deduction.
</p>

<p>
Intersection types can be seen from a programming-language perspective as a type system, providing static information about program behaviour, and from a semantic perspective as a presentation of a relation-based mathematical model of programs and proofs. The novelty of this project is to use non-commutative types to model sequential computation. Expressing such types effectively is made possible by the open-deduction formalism, an approach to proof theory that can alternatively be viewed as a presentation of category-theory-based semantics. The project builds on our recent work exploring intersection types in this proof formalism. A background that includes lambda-calculus or category theory would help you make a good start on it.
</p>

<h3>
Proof Mining: Algorithms From Proofs in Mathematics
</h3>

<p>
<a href="https://t-powell.github.io/">Tom Powell</a>
</p>

<p>
Many mathematical theorems are based on the statement that something exists. For example, Euclid's theorem on the infinitude of prime numbers says that for any number \(N\) there exists some prime number \(p\) greater than \(N\). For such statements it is natural to ask: Can we produce an algorithm for computing the thing that we claim to exist? The proof of Euclid's theorem implicitly contains an algorithm* for finding the next prime number, and we call such proofs "constructive". Unfortunately, Turing's famous discovery that the Halting problem is undecidable highlights the fact that not all proofs are constructive, and that in general one cannot always produce algorithms for witnessing existential statements. After all, for any Turing machine \(M\) on input \(u\) there exists a boolean truth value which tells us whether or not it halts, but a general algorithm which on inputs \(M\) and \(u\) returns such a boolean is not possible by Turing's result.
</p>

<p>
The question of whether or not we can produce an algorithm for a given existential theorem is complex, and requires a deep understanding of the nature of mathematical proofs as objects in their own right. The last 20-30 years has seen the growth of an exciting research area - colloquially known as "proof mining" - which addresses this question and explores the limits of what is algorithmically possible in mathematics. It turns out that by applying techniques from proof theory, it is often possible to obtain surprising algorithms from proofs that appear to be nonconstructive. In the process, one is typically required to tackle more general challenges, such as "how should mathematical objects be represented?" and "what is the fundamental structure of this proof?", and the end result is often an abstract framework which generalises and unifies classes of mathematical theorems.
</p>

<p>
Proof mining has already achieved impressive results several areas of mathematics, including functional analysis, ergodic theory and commutative algebra. As a PhD student, you would explore developing this research program in a new direction.
</p>

<p>
*Take the number \(N! + 1\), which is not divisible by any number from \(2\) to \(N\), and search for its smallest prime factor, which must therefore by greater than \(N\).
</p>

<h2>
Candidate Requirements
</h2>

<p>
Applicants should hold, or expect to receive, a First Class or good Upper Second Class Honours degree (or the equivalent) in Mathematics or Computer Science. A master’s level qualification would also be advantageous.
</p>

<p>
Non-UK applicants will also be required to have met the <a href="https://www.findaphd.com/common/clickCount.aspx?theid=127676&type=184&DID=76&url=https%3a%2f%2fwww.bath.ac.uk%2fcorporate-information%2fpostgraduate-english-language-requirements-for-international-students%2f">English language entry requirements</a> of the University of Bath.
</p>

<h2>
Enquiries and Applications
</h2>

<p>
Informal enquiries are welcomed and should be directed to the prospective supervisor:
<ul>
<li><a href="mailto:masrjb@bath.ac.uk">Russell Bradford</a>
<li><a href="mailto:masjhd@bath.ac.uk">James Davenport</a>
<li><a href="mailto:ag248@bath.ac.uk">Alessio Guglielmi</a>
<li><a href="mailto:wbh22@bath.ac.uk">Willem Heijltjes</a>
<li><a href="mailto:jl317@bath.ac.uk">James Laird</a>
<li><a href="mailto:gam23@bath.ac.uk">Guy McCusker</a>
<li><a href="mailto:trjp20@bath.ac.uk">Tom Powell</a>
</ul>
Formal applications should be made via the University of Bath’s <a href="https://www.findaphd.com/common/clickCount.aspx?theid=127676&type=184&DID=76&url=https%3a%2f%2fsamis.bath.ac.uk%2furd%2fsits.urd%2frun%2fsiw_ipp_lgn.login%3fprocess%3dsiw_ipp_app%26code1%3dRDUCM-FP01%26code2%3d0015">online application form for a PhD in Computer Science (full-time)</a>.
</p>

<p>
More information about applying for a PhD at Bath may be found on our <a href="https://www.findaphd.com/common/clickCount.aspx?theid=127676&type=184&DID=76&url=http%3a%2f%2fwww.bath.ac.uk%2fguides%2fhow-to-apply-for-doctoral-study%2f">website</a>.
</p>

<p>
Anticipated start date: 4 October 2021.
</p>

<h2>
Funding Notes
</h2>

<p>
Candidates applying for this project may be considered for a 3.5-year studentship from the Engineering and Physical Sciences Council (EPSRC DTP). Funding covers tuition fees, a stipend (£15,285 per annum, 2020/21 rate) and research/training expenses (£1,000 per annum). EPSRC DTP studentships are open to both Home and International students; however, in line with guidance from UK Research and Innovation (UKRI), the number of awards available to International candidates will be limited to 30% of the total.
</p>

<p class="Signature">
8.12.2020 <a href="http://alessio.guglielmi.name/index.html">Alessio Guglielmi</a> <a href="mailto:AlessioATGuglielmi.name">email</a>
</p>

</body>
</html>
